./Animal.cpp
# include "Animal.hpp"

Animal::Animal() : type("Animal")
{
	std::cout << GREEN << "Default constructor called" << RESET << std::endl;
}

Animal::Animal(const std::string type) : type(type)
{
	std::cout << GREEN << "Type constructor called" << RESET << std::endl;
}

Animal::Animal(const Animal& other) : type(other.type)
{
	std::cout << GREEN << "Copy constructor called" << RESET << std::endl;
}

Animal& Animal::operator=(const Animal& other)
{
	std::cout << GREEN << "Assignation operator called" << RESET << std::endl;
	if (this == &other)
		return *this;
	type = other.type;
	return *this;
}

Animal::~Animal()
{
	std::cout << RED << "Destructor called" << RESET << std::endl;
}

std::string		Animal::getType() const
{
	return type;
}

std::string		Animal::setType(std::string type)
{
	this->type = type;
	return type;
}


void	Animal::makeSound() const
{
	std::cout << CYAN << "Animal sound" << RESET << std::endl;
}
./Animal.hpp
# ifndef ANIMAL_HPP
# define ANIMAL_HPP

# include <iostream>

#define RESET   "\033[0m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"
#define WHITE   "\033[37m"


class Animal
{
protected:
	std::string type;

public:
	Animal();
	Animal(const std::string type);
	Animal(const Animal& other);
	Animal& operator=(const Animal& other);
	virtual	~Animal();

	std::string		getType() const;
	std::string		setType(std::string type);
	virtual void	makeSound() const;
};

# endif // ANIMAL_HPP
./Cat.cpp
# include "Cat.hpp"

Cat::Cat() : Animal("Cat")
{
	std::cout << GREEN << "Cat Default constructor called" << RESET << std::endl;
}

Cat::Cat(const::Cat& other) : Animal(other)
{
	std::cout << GREEN << "Cat Copy constructor called" << RESET << std::endl;
}

Cat& Cat::operator=(const Cat& other)
{
	std::cout << GREEN << "Cat Assignation operator called" << RESET << std::endl;
	if (this == &other)
		return *this;
	Animal::operator=(other);
	return *this;
}

Cat::~Cat()
{
	std::cout << RED << "Cat Destructor called" << RESET << std::endl;
}

void Cat::makeSound() const
{
	std::cout << CYAN << "nyan" << RESET << std::endl;
}

./Cat.hpp
# ifndef CAT_HPP
# define CAT_HPP

# include "Animal.hpp"

class Cat : public Animal
{
public:
	Cat();
	Cat(const Cat& other);
	Cat& operator=(const Cat& other);
	virtual ~Cat();

	virtual void makeSound() const;
};

# endif // CAT_HPP
./Dog.cpp
# include "Dog.hpp"

Dog::Dog() : Animal("Dog")
{
	std::cout << GREEN << "Dog Default constructor called" << RESET << std::endl;
}

Dog::Dog(const::Dog& other) : Animal(other)
{
	std::cout << GREEN << "Dog Copy constructor called" << RESET << std::endl;
}

Dog& Dog::operator=(const Dog& other)
{
	std::cout << GREEN << "Dog Assignation operator called" << RESET << std::endl;
	if (this == &other)
		return *this;
	Animal::operator=(other);
	return *this;
}

Dog::~Dog()
{
	std::cout << RED << "Dog Destructor called" << RESET << std::endl;
}

void Dog::makeSound() const
{
	std::cout << CYAN << "inu" << RESET << std::endl;
}

./Dog.hpp
# ifndef DOG_HPP
# define DOG_HPP

# include "Animal.hpp"

class Dog : public Animal
{
public:
	Dog();
	Dog(const Dog& other);
	Dog& operator=(const Dog& other);
	virtual ~Dog();

	virtual void makeSound() const;
};

# endif // DOG_HPP
./main.cpp
#include <iostream>
#include "Animal.hpp"
#include "Dog.hpp"
#include "Cat.hpp"
#include "WrongAnimal.hpp"
#include "WrongCat.hpp"

int main()
{
	const Animal* meta = new Animal();
	const Animal* j = new Dog();
	const Animal* i = new Cat();

	std::cout << j->getType() << " " << std::endl;
	std::cout << i->getType() << " " << std::endl;

	i->makeSound(); // ネコの鳴き声を出力するはず！
	j->makeSound();
	meta->makeSound();

	delete meta;
	delete j;
	delete i;

	std::cout << "\n=== Wrong Animal Test ===" << std::endl;
	const WrongAnimal* wrongMeta = new WrongAnimal();
	const WrongAnimal* wrongCat = new WrongCat();
	WrongCat wrongCat2; 

	std::cout << "wrongCat type: " << wrongCat->getType() << std::endl;

	wrongCat->makeSound();   // WrongCat::makeSoundだが、virtual でないため注意
	wrongMeta->makeSound();  // WrongAnimal::makeSound
	wrongCat2.makeSound();  // WrongCat::makeSound
	
	delete wrongCat;
	delete wrongMeta;


	return 0;
}
./Makefile
NAME = polymorphism

SRCS = main.cpp Animal.cpp Dog.cpp Cat.cpp WrongAnimal.cpp WrongCat.cpp
OBJS = $(SRCS:.cpp=.o)

CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98
# CXXFLAGS += -fsanitize=address

all: $(NAME)

$(NAME): $(OBJS)
	$(CXX) $(CXXFLAGS) $(OBJS) -o $(NAME)

%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re


./merged_cs_files.txt

./WrongAnimal.cpp
# include "WrongAnimal.hpp"

WrongAnimal::WrongAnimal() : type("WrongAnimal")
{
	std::cout << GREEN << "Default constructor called" << RESET << std::endl;
}

WrongAnimal::WrongAnimal(const std::string type) : type(type)
{
	std::cout << GREEN << "Type constructor called" << RESET << std::endl;
}

WrongAnimal::WrongAnimal(const WrongAnimal& other) : type(other.type)
{
	std::cout << GREEN << "Copy constructor called" << RESET << std::endl;
}

WrongAnimal& WrongAnimal::operator=(const WrongAnimal& other)
{
	std::cout << GREEN << "Assignation operator called" << RESET << std::endl;
	if (this == &other)
		return *this;
	type = other.type;
	return *this;
}

WrongAnimal::~WrongAnimal()
{
	std::cout << RED << "Destructor called" << RESET << std::endl;
}

std::string		WrongAnimal::getType() const
{
	return type;
}

std::string		WrongAnimal::setType(std::string type)
{
	this->type = type;
	return type;
}


void	WrongAnimal::makeSound() const
{
	std::cout << CYAN << "WrongAnimal sound" << RESET << std::endl;
}
./WrongAnimal.hpp
# ifndef WRONGANIMAL_HPP
# define WRONGANIMAL_HPP

# include <iostream>

#define RESET   "\033[0m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"
#define WHITE   "\033[37m"

class WrongAnimal
{
protected:
	std::string type;

public:
	WrongAnimal();
	WrongAnimal(const std::string type);
	WrongAnimal(const WrongAnimal& other);
	WrongAnimal& operator=(const WrongAnimal& other);
	~WrongAnimal();

	std::string		getType() const;
	std::string		setType(std::string type);
	void	makeSound() const;
};

# endif // WRONGANIMAL_HPP
./WrongCat.cpp
# include "WrongCat.hpp"

WrongCat::WrongCat() : WrongAnimal("WrongCat")
{
	std::cout << GREEN << "WrongCat Default constructor called" << RESET << std::endl;
}

WrongCat::WrongCat(const::WrongCat& other) : WrongAnimal(other)
{
	std::cout << GREEN << "WrongCat Copy constructor called" << RESET << std::endl;
}

WrongCat& WrongCat::operator=(const WrongCat& other)
{
	std::cout << GREEN << "WrongCat Assignation operator called" << RESET << std::endl;
	if (this == &other)
		return *this;
	WrongAnimal::operator=(other);
	return *this;
}

WrongCat::~WrongCat()
{
	std::cout << RED << "WrongCat Destructor called" << RESET << std::endl;
}

void WrongCat::makeSound() const
{
	std::cout << CYAN << "nyan" << RESET << std::endl;
}

./WrongCat.hpp
# ifndef WRONGCAT_HPP
# define WRONGCAT_HPP

# include "WrongAnimal.hpp"

class WrongCat  : public WrongAnimal 
{
public:
	WrongCat ();
	WrongCat (const WrongCat & other);
	WrongCat & operator=(const WrongCat & other);
	~WrongCat ();

	void makeSound() const;
};

# endif // WRONGCAT_HPP
